## 解題

## DFS+DP

我們會從左上角開始DFS過程中有幾種狀況

* 如果不在範圍內直接return 0
* 如果現在這格是障礙物就return 0
* 如果這格是終點就return -1
* 如果這格已經走過,就直接return數字
* 如果沒走過則會dfs右邊與下面,獲得數字後加起來

這邊經過測試把function寫在class內會快一些

我原本是用vector直接更改與access,結果速度是別人的好幾倍(所以才會用負數,與障礙物的1做區隔)

後面建立array來去當作dp的存取,速度就快上了好幾倍

##Better DP

後面看Discuss後看到一個更好的寫法

由於我們只能從左邊與上面來,所以我們可以一列一列去construct DP

0 -------->

1 -------->

2 -------->

3 -------->

一個點的可能情況等於(上方的path counts)+(左邊的path counts)

要注意如果那格為障礙物要直接設為0

照理來說我們必須建立2維的dp表格

但我們的可能情況只有上方與左邊,我們用1維的陣列就能儲存

假如一列已經consruct完,我們需要construct新的一列此時array裡的數值就是上面那列的數值,我們再從左邊開始construct,就能同時獲得上面與左邊的值

