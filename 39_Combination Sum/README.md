## 解題
原本想很久看有沒有什麼DP的做法,但後面看題目的要求是所有可能的組合,而不是有多少組合數,所以就果斷用dfs了

這邊的dfs與之前寫得不太一樣,以前是加入某個東西傳下去,傳回來的時候再把那個東西去掉

這邊的dfs稍微有點不同,假如我現在要用第i個數字,那我第i個數字可以放0~n個在這vector中(n為不超過target的數量)

我每多放一個就要繼續dfs(當然一開始我也可以選擇不放直接dfs)

例如我現在在處理**2**這個數字,我可以有以下幾種dfs

* []
* [2]
* [2,2]
* [2,2,2]......

當我超過target無法再放入2時,我需要把我的2全部pop掉,因為重頭到尾我們都是用同一個vector(為了效能),我們必須弄回原本的狀態

例如:

* [] -> [3,3,3] (再加入下個2之前必須弄回原本的狀態,把3清掉)
* [2] -> [2,3,3,3] (再加入下個2之前必須弄回原本的狀態,把3清掉)
* [2,2]
* [2,2,2]......


