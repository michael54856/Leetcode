## 解題
O(N)

一開始看到題目原本想用dfs,但想了一下感覺需要很久

之後想了一個DP的解法

DP的陣列是儲存這個substring有幾種構成的可能

我的想法是先從做右邊開始做,如果往左邊串上新的字元的話,可能會有幾種情況??

其實可以把新串上的字元分成以下幾種情況:

* 0
* 1
* 2
* 其他

## 0

如果是0開頭的字串,是無法轉換的 -> dp[i] = 0

## 1

如果是1開頭的字串,可以是2位數,也可以是1位數,我們把這兩個substring的可能性相加 -> dp[i] = dp[i+1] + dp[i+2];

## 2

如果是1開頭的字串,可以是2位數,也可以是1位數,其中只有前一個字元為0~6才可能以2位數構成

if(s[i+1] >= '0' && s[i+1] <= '6') -> dp[i] = dp[i+1] + dp[i+2];

else -> dp[i] = dp[i+1];

## 其他

其他的話就只能一位數構成,所以可能性不會增加 -> dp[i] = dp[i+1];